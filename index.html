<!DOCTYPE html>
<html>

	<head>
		<title>Rexmeck Drawable Generator</title>
		<style>
			.default-font {
				font-family: Arial, Helvetica, sans-serif;
				font-size: 0.5cm;
				font-weight:lighter;
			}
			
			.default-button {
				color: #111;
				border: 2px solid #888;
				border-radius: 4px;
				background-color: #eee;
			}

			body {
				height: 100vh;
				margin: 0;
				background-color: #000;
				padding: 0;
				position: relative;
			}

			.header {
				overflow: hidden;
				background-color: #202020;
				top: 0;
				left: 0;
				right: 0;
				bottom: 100%;
				max-height: 8cm;
				z-index: 99;
			}

			#generating {
				display: none;
			}
			.middle-align {
				overflow: hidden;
				max-width: 960px;
				margin-left: auto;
				margin-right: auto;
			}
			
			.shadow {
				box-shadow: 0px 20px 20px 0px #00000040;
			}

			.page-element {
				margin-top: 30px;
				padding-top: 30px;
				padding-bottom: 30px;
			}

		</style>
	</head>
	
	<body>
		<div class="header shadow">
			<h1 align="center" class="default-font" style="font-size: 1cm; color:#808080; margin-top: 15px;">Rexmeck Drawable Generator</h1>
		</div>
		<!--Main page-->
		<div class="middle-align shadow page-element" style="background-color: #fafafa; min-width: 120px;">
			<div style="padding-left: 3.5%; padding-right: 5%;">
				<label class="default-font">Input: </label>
				<br>
				<button name="generate" onclick="generate()" class="default-button">Generate</button>
				<input type="file" id="input" accept="image/*" class="default-button">
				<label id="generating" class="default-font" ></label>
				<br>
				<br>
				<label class="default-font">Output: </label>
				<br>
				<br>
				<textarea id="output" wrap="soft" spellcheck="false" style="max-width:100%; min-width: 100%; height: 250px; resize: vertical;"> </textarea>
			</div>
		</div>
		
		<div class="middle-align shadow page-element" style=" background-color: #fafafa; min-width: 120px;">
			<div style="padding-left: 3.5%; padding-right: 5%;">
				<h1 align="center" class="default-font">Advanced Settings</h1>
				<br>
				<label class="default-font">Source Image Path:</label>
				<br>
				<input type="text" id="imagePathTextBox" value="/assetmissing.png" class="default-font" style="max-width:100%; min-width: 100%;" title="Change our base sprite to make drawables on. Its recommended to use the default">
				<br>
				<br>
				<label class="default-font">Green Index</label>
				<input type="text" id="greenIndexTextBox" value="00" maxlength="2" class="default-font" style="max-width:36px; min-width: 0%;" title="Useful for animated drawables">
				<br>
				<br>
				<input type="checkbox" id="compressColorCheckBox" class="default-font" title="Round color values to smaller hex color"></input>
				<label class="default-font">Color Compression</label>
				<br>
				<br>
				<input type="checkbox" id="pixelMapOnlyCheckBox" class="default-font" title="Useful for animated drawables (experimental!)"></input>
				<label class="default-font">Pixel map data only</label>
				<br>
				<br>
				<h1 align="center" class="default-font">Legacy Settings</h1>
				<br>
				<input type="checkbox" id="checkboxlegacy" class="default-font" title="Use old method if the new method doesn't work properly"></input>
				<label class="default-font">Generate legacy drawables</label>
				<br>
				<br>
				<input type="checkbox" id="bypassTransparentLastSign" class="default-font" title="The last sign will not have transparent coords removal (slightly saves some data)"></input>
				<label class="default-font" >Bypass transparent on last signplaceholder</label>
				<br>
				<br>
				<input type="checkbox" id="RetainColorValue" class="default-font" title="Takes full transparent with color codes instead of turning it into 0000."></input>
				<label class="default-font">Retain color value even if transparent</label>
				<br>
				<br>
			</div>
		</div>

	</body>
	
	<script>
		var ready = true

		//Util credits from people on stackoverflow
		function componentToHex(c)
		{
			var hex = c.toString(16);
			return hex.length == 1 ? "0" + hex : hex;
		}
		
		function sameHex(v)
		{
			for(var i=0;i<16;i++)
			{
				if(v == i * 17)
				{
					return true;
				}
			}
			return false;
		}
		function rgbaToHex(r, g, b, a, TransparentCheck)
		{
			//very bad coding here
			r = Math.min(r,255);
			g = Math.min(g,255);
			b = Math.min(b,255);
			a = Math.min(a,255);

			if(a == 0 && !document.getElementById("RetainColorValue").checked && TransparentCheck) {
				return "0000";
			}

			if(sameHex(r) && sameHex(g) && sameHex(b))
			{
				if (a == 255)
				{
					return componentToHex(r).substring(0, 1) + componentToHex(g).substring(0, 1) + componentToHex(b).substring(0, 1);
				}
				else
				{
					if(sameHex(a))
					{
						return componentToHex(r).substring(0, 1) + componentToHex(g).substring(0, 1) + componentToHex(b).substring(0, 1) + componentToHex(a).substring(0, 1);
					}
				}
			}
			if(a == 255)
			{
				return componentToHex(r) + componentToHex(g) + componentToHex(b)
			}
			return componentToHex(r) + componentToHex(g) + componentToHex(b) + componentToHex(a);
		}

		function rgbaToHexNoTransparentCheck(r, g, b, a)
		{
			r = Math.min(r,255);
			g = Math.min(g,255);
			b = Math.min(b,255);
			a = Math.min(a,255);
			if(sameHex(r) && sameHex(g) && sameHex(b))
			{
				if (a == 255)
				{
					return componentToHex(r).substring(0, 1) + componentToHex(g).substring(0, 1) + componentToHex(b).substring(0, 1);
				}
				else
				{
					if(sameHex(a))
					{
						return componentToHex(r).substring(0, 1) + componentToHex(g).substring(0, 1) + componentToHex(b).substring(0, 1) + componentToHex(a).substring(0, 1);
					}
				}
			}

			if(a == 255)
			{
				return componentToHex(r) + componentToHex(g) + componentToHex(b)
			}
			return componentToHex(r) + componentToHex(g) + componentToHex(b) + componentToHex(a);
		}

		function compressColor(c)
		{
			return [
				Math.round(c[0] / 17) * 17,
				Math.round(c[1] / 17) * 17,
				Math.round(c[2] / 17) * 17,
				Math.round(c[3] / 17) * 17,
			]
		}

		//button callback
		function generate(){
			let outputText = document.getElementById("output");
			outputText.value = "";

			let generatingtext = document.getElementById("generating");
			generatingtext.style.display = "initial";
			generatingtext.innerHTML = "Generating...";
			
			if (ready && document.getElementById("input").files.length == 1) {
				ready = false
				let reader = new FileReader();
				let f = document.getElementById("input").files[0];

				reader.onload = function(a)
				{
					let img = new Image;
					img.onload = function(){

						if(img.height <= 256 && img.width <= 256 && !document.getElementById("checkboxlegacy").checked){
							generatingtext.innerHTML = "Generated!";
							outputText.value = drawFade(
								img,
								{
									pixelMapOnly: document.getElementById("pixelMapOnlyCheckBox").checked,
									imagePath: document.getElementById("imagePathTextBox").value,
									compressColor: document.getElementById("compressColorCheckBox").checked,
									greenIndex: document.getElementById("greenIndexTextBox").value
								}
							);
						}
						else
						{
							generatingtext.innerHTML = "Generated (legacy)!";
							outputText.value = drawLegacy(img);
						}

						ready = true
					};
					img.src = a.target.result;
				}

				reader.readAsDataURL(f);
			}
			else
			{
				generatingtext.style.display = "none";
			}
			
			
		}

		function palettesCount(image)
		{
			let img = document.createElement('canvas');
			img.width = image.width;
			img.height = image.height;
			let context2d = img.getContext('2d');
			context2d.drawImage(image, 0,0);
			let palettes = {}
			for (x = 0; x < img.width; x++)
			{
				for (y = 0; y < img.height; y++)
				{
					let colorData = context2d.getImageData(x, y, 1, 1).data;
					let hex = rgbaToHex(colorData[0], colorData[1], colorData[2], colorData[3]);
					palettes[hex] = (palettes[hex] != null ? palettes[hex] : 0) + 1;
				}
			}
			return palettes;
		}

		function makeReplaces(palettes, greenIndex)
		{
			let repl = {};
			let ind = [0, 0, 0];
			let greenIndex2 = greenIndex ? greenIndex : 0;
			if(greenIndex2 < 119)
			{
				ind[1] = Math.ceil(greenIndex2 / 17) + 1;
				greenIndex2 = 255;
			}

			for(var key in palettes)
			{
				//if the hex are long and has 6 duplicates we can start replacing
				if(key.length > 4 && palettes[key] > 6)
				{
					repl[key] = rgbaToHexNoTransparentCheck(ind[0]*17,ind[1]*17,ind[2]*17,0);
					ind[0] += 1;
					if(ind[0] > 15)
					{
						ind[0] = 0;
						ind[2] += 1;
					}
					if(ind[2] > 15)
					{
						ind[2] = 0;
						ind[1] += 1;
					}
					if(ind[1]*17 >= greenIndex2) //too many palettes shouldnt really reach it unless the user tries
					{
						break;
					}
				}
			}
			return repl;
		}

		function createReplaces(repl)
		{
			let directives = "?replace"
			for(var key in repl)
			{
				directives += ";" + repl[key] + "=" + key;
			}
			if(directives == "?replace")
			{
				return "";
			}
			return directives;
		}

		//drawable
		function drawFade(image, options)
		{
			options = options ? options : {};

			let img = document.createElement('canvas');
			img.width = options.width ? options.width : image.width;
			img.height = options.height ? options.height : image.height;
			
			context2d = img.getContext('2d');
			context2d.drawImage(image, -(options.offset ? options.offset[0] : 0), -(options.offset ? options.offset[1] : 0));

			let srcImageDirectory = options.imagePath ? options.imagePath : "/assetmissing.png";

			//green index validation
			let greenIndex = Math.min(Math.max(parseInt(options.greenIndex, 16), 0), 255);
			if(isNaN(greenIndex))
			{
				greenIndex = 0;
			}

			let baseDirectives = "?crop;0;0;1;1?setcolor=fff?replace;fff0=fff?border=1;fff;000?scale=1.15;1.12?crop;1;1;3;3"
			
			//setgradient
			baseDirectives +=
				"?replace" +
				";fbfbfb=" + rgbaToHex(0, greenIndex, 0,255) +
				";eaeaea=" + rgbaToHex(img.width, greenIndex, 0,255) +
				";e4e4e4=" + rgbaToHex(0, greenIndex, img.height, 255) +
				";6a6a6a=" + rgbaToHex(img.width, greenIndex, img.height, 255);

			//scalefade
			baseDirectives += "?multiply=fff0";
			baseDirectives += "?scale=" + (img.width - 0.5);
			if(img.width != img.height)
			{
				baseDirectives += ";" + (img.height - 0.5);
			}

			//crop left overs
			let crop = [
				0,0,
				img.width, img.height
			]

			if(img.width > 255)
			{
				crop[0] += 1;
				crop[2] += 1;
			}

			if(img.height > 255)
			{
				crop[1] += 1;
				crop[3] += 1;
			}
			
			baseDirectives += "?crop=" + crop.join(";");


			//palettes tags
			let toReplace = {};
			if(!options.compressColor)
			{
				let palettes = palettesCount(image);
				toReplace = makeReplaces(palettes, greenIndex);
			}

			//pixeldata
			let pixelData = "?replace"
			for(let x = 0; x < img.width; x++)
			{
				for(let y = 0; y < img.height; y++)
				{
					let colorData = context2d.getImageData(x, img.height - y - 1, 1, 1).data;
					if (colorData[3] > 0)
					{
						if (options.compressColor)
						{
							colorData = compressColor(colorData)
						}
						let colorHex = rgbaToHex(colorData[0], colorData[1], colorData[2], colorData[3]);

						pixelData +=  ";" 
								+ rgbaToHexNoTransparentCheck(x, greenIndex, y,0) 
								+ "=" 
								+ (toReplace[colorHex] != null ? toReplace[colorHex] : colorHex); //use palette tags or original color
					}
				}
			}

			//output

			if(options.pixelMapOnly)
			{
				srcImageDirectory = "";
				baseDirectives = "";
			}
			if(pixelData == "?replace")
			{
				return srcImageDirectory;
			}

			return srcImageDirectory + baseDirectives + pixelData + createReplaces(toReplace);
		}

		function drawLegacy(image, options)
		{
			let img = document.createElement('canvas');
			img.width = image.width;
			img.height = image.height;

			context2d = img.getContext('2d');
			context2d.drawImage(image, 0, 0, image.width, image.height);
			
			options = options ? options : {};
			let srcImageDirectory = options.imagePath ? options.imagePath : "/assetmissing.png";
			
			let signSize = [32, 8];
			let signDirectory = "/objects/outpost/customsign/signplaceholder.png";
			let signColors = [["00000000"]];

			let bypassTransparentLastSign = document.getElementById("bypassTransparentLastSign").checked;
			let RetainColorValue = document.getElementById("RetainColorValue").checked;
			let compressColors = document.getElementById("compressColorCheckBox").checked;

			for(let x=1;x<=signSize[0];x++)
			{
				signColors[x] = [];
				for(let y=1;y<=signSize[1];y++)
				{
					let xx = (x+"");
					let yy = (x+"");

					if(x<10)
						xx = "0"+x;
					if(y<10)
						yy = "0"+y;

					signColors[x-1][y-1] = xx + "00" + yy + "00"
				}
			}
			//directives init
			let directives = "?crop=;0;0;1;1?setcolor=fff?replace;fff=ffffff02;fff0=ffffff02?scalenearest=" + image.width + ";" + image.height;
			
			//calculates how much signs to be place x y
			let signs = [
				Math.ceil(image.width / signSize[0]),
				Math.ceil(image.height / signSize[1]),
			]

			//palettes tags
			let toReplace = {};
			if(!options.compressColor)
			{
				let palettes = palettesCount(image);
				toReplace = makeReplaces(palettes, 0);
			}

			//iterate sign blocks
			for(let sy = 0; sy < signs[1];sy++)
			{
				for(let sx = 0; sx < signs[0];sx++)
				{
					//gets sign relative position to the image
					let spos = [sx * signSize[0], sy * signSize[1]];

					//new sign
					let sign = "?blendmult=" + signDirectory + ";" + (-sx * signSize[0]) + ";" + -(sy * signSize[1]);
					let palettes = "?replace";
					hasColor = false;
					
					//iterate pixels + sign blocks
					for(let x=0; x<signSize[0];x++)
					{
						for(let y=0; y<signSize[1];y++)
						{
							if (image.height > (spos[1] + y) && image.width > (spos[0] + x))
							{
								//get pixel from pos
								let colorData = context2d.getImageData(spos[0] + x, image.height - (spos[1] + y + 1) , 1, 1).data;

								if(colorData[3] > 0 || RetainColorValue)
								{
									hasColor = true;
								}

								//apply pixel
								if(sx + 1==signs[0] && sy + 1==signs[1] && colorData[3] == 0 && bypassTransparentLastSign){
									if (compressColors)
									{
										colorData = compressColor(colorData)
									}
									let colorHex = rgbaToHex(colorData[0],colorData[1],colorData[2],colorData[3]);
									palettes += ";" + signColors[x][y] + "=" + (toReplace[colorHex] != null ? toReplace[colorHex] : colorHex);
								}
								else
								{
									if (compressColors)
									{
										colorData = compressColor(colorData)
									}
									let colorHex = rgbaToHex(colorData[0],colorData[1],colorData[2],colorData[3]);
									palettes += ";" + signColors[x][y] + "=" + (toReplace[colorHex] != null ? toReplace[colorHex] : colorHex);
								}
							}
						}
					}
					if (hasColor && palettes != "?replace")
					{
						directives += sign + palettes;
					}
				}
			}
			
			//final processing
			return srcImageDirectory + directives + createReplaces(toReplace);
		}

		//web visuals

		function lerp(a,b,r)
		{
			return a+(b-a)*r;
		}

		var speed = 1/16;

		var lastColor = [0, 212, 219];
		var targetColor = [70, 112, 16];
			
		var current_lastColor = [0, 0, 0];
		var current_targetColor = [0, 0, 0];

		function tick()
		{
			current_lastColor = [lerp(current_lastColor[0], lastColor[0], speed), lerp(current_lastColor[1], lastColor[1], speed), lerp(current_lastColor[2], lastColor[2], speed)];
			current_targetColor = [lerp(current_targetColor[0], targetColor[0], speed), lerp(current_targetColor[1], targetColor[1], speed), lerp(current_targetColor[2], targetColor[2], speed)];
			document.body.style.backgroundImage = "linear-gradient(90deg, rgb("+current_targetColor[0]+","+current_targetColor[1]+","+current_targetColor[2]+"),rgb("+current_lastColor[0]+","+current_lastColor[1]+","+current_lastColor[2]+"))";
		}

		function tick2()
		{
			lastColor = targetColor;
			targetColor = [Math.random() * 255, Math.random() * 255, Math.random() * 255];
		}

		tick();
		tick2();

		setInterval(tick2,5000);
		setInterval(tick,64);
	</script>
</html>