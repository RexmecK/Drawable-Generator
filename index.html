<!DOCTYPE html>
<html>

    <head>
        <title>Rexmeck Drawable Generator</title>
        <style>
            .default-font {
                font-family: Arial, Helvetica, sans-serif;
                font-size: 16px;
            }
            
            .default-button {
                color: #111; 
                border: 2px solid #888; 
                border-radius: 4px; 
                background-color: #eee;
            }
            
            .header {
                overflow: hidden;
                background-color: #232323;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0%;
                max-height: 60px;
                z-index: 99;
                position: fixed;
            }

            .middle-align {
                overflow: hidden;
                margin-left: 5%;
                margin-right: 5%;
            }
        </style>
    </head>
    
    <body>
        <div class="header">
            <div class="middle-align" style="padding-top: 20px;background-color: #323232; box-shadow: 0px 0px 5px black; min-height: 80px;">
                <p align="center" style="font-size: 18px 50%; color: white;" class="default-font">Rexmeck Drawable Generator</p>
            </div>
        </div>
        <div class="middle-align" style="padding-top: 60px; box-shadow: 0px 0px 5px black; background-color: #fafafa; min-width: 120px;">
            <div style="padding-left: 8px; padding-right: 8px;">
                <label class="default-font">Input: </label>
                <br>
                <button name="generate" onclick="generate()" class="default-button">Generate</button>
                <input type="file" id="input" accept="image/*" class="default-button">
                <br>
                <label class="default-font">Src Image Path:</label>
                <input type="text" id="srcPath" value="/assetmissing.png">
                <br>
                <label class="default-font">Src Image Size:</label>
                <input type="number" id="srcX" value="64" min="1">
                <input type="number" id="srcY" value="64" min="1">
                <br>
                <input type="checkbox" id="btrans" class="default-font">Bypass transparent on last signplaceholder</input>
                <br>
                <input type="checkbox" id="ctrans" class="default-font">Retain color value even if transparent</input>
                <br>
                <label class="default-font">Output: </label>
                <textarea id="output" wrap="soft" style="max-width:100%; min-width: 100%; resize: vertical;"> </textarea>
            </div>
        </div>
    </body>
    
    <script>
        //Util credits from people on stackoverflow
        function componentToHex(c) {
            var hex = c.toString(16);
            return hex.length == 1 ? "0" + hex : hex;
        }
        
        function hexEnd0(v) {
            for(var i=0;i<16;i++){
                if(v == i * 17) {
                    return true;
                }
            }
            return false;
        }

        function rgbaToHex(r, g, b, a) {
            //very bad coding here

            if(a == 0 && !document.getElementById("ctrans").checked) {
                return "0000";
            }

            if(hexEnd0(r) && hexEnd0(g) && hexEnd0(b)) {
                if (a == 255) {
                    return componentToHex(r).substring(0, 1) + componentToHex(g).substring(0, 1) + componentToHex(b).substring(0, 1);
                }
                else{
                    if(hexEnd0(a)){
                        return componentToHex(r).substring(0, 1) + componentToHex(g).substring(0, 1) + componentToHex(b).substring(0, 1) + componentToHex(a).substring(0, 1);
                    }
                }
            }

            return componentToHex(r) + componentToHex(g) + componentToHex(b) + componentToHex(a);
        }
        //

        //button callback
        function generate(){
            if(document.getElementById("input").files.length == 1 && document.getElementById("srcX").value > 0 && document.getElementById("srcY").value > 0) {
                let reader = new FileReader();
                let f = document.getElementById("input").files[0];
                reader.onload = function(a) 
                {
                    let img = new Image;
                    img.onload = function() {  document.getElementById("output").value = draw(img); } ;
                    img.src = a.target.result;
                }
                reader.readAsDataURL(f);
            }
        }
        
        function draw(image) {
            //we would create a canves to get pixel colors
            let img = document.createElement('canvas');
            img.width = image.width;
            img.height = image.height;
            context2d = img.getContext('2d');
            context2d.drawImage(image, 0, 0, image.width, image.height);
            
            let srcDirectory = document.getElementById("srcPath").value;
            let srcSize = [document.getElementById("srcX").value, document.getElementById("srcY").value];
            
            let signSize = [32, 8];
            let signDirectory = "/objects/outpost/customsign/signplaceholder.png";
            let signColors = [["00000001"]];

                for(let x=1;x<=signSize[0];x++){
                    signColors[x] = [];
            for(let y=1;y<=signSize[1];y++){
                    signColors[x][y] = "";
                    if(x < 10){ signColors[x][y] += "0" + x; } else { signColors[x][y] += x;}
                    signColors[x][y] += "00";
                    if(y < 10){ signColors[x][y] += "0" + y; } else { signColors[x][y] += y;}
                    signColors[x][y] += "01";
                }
            }
            //directives init
            let directives = "?setcolor=ffff?replace;0000=ffff;fff0=ffff?scalenearest=" + (image.width / srcSize[0]) + ";" + (image.height / srcSize[1]);
            
            //calculates how much signs to be place x y
            signs = [
                Math.ceil(image.width / signSize[0]),
                Math.ceil(image.height / signSize[1]),
            ]

            //iterate sign blocks
                for(let sy = 0; sy < signs[1];sy++){
            for(let sx = 0; sx < signs[0];sx++){

                    //gets sign relative position to the image
                    let spos = [sx * signSize[0], sy * signSize[1]];

                    //new sign
                    let sign = "?blendmult=" + signDirectory + ";" + (-sx * signSize[0]) + ";" + -(sy * signSize[1]);
                    let palletes = "?replace";
                    hasColor = false;
                    
                    //iterate pixels + sign blocks
                    for(let x=0; x<signSize[0];x++) 
                    {
                        for(let y=0; y<signSize[1];y++)
                        {
                            if (img.height > (spos[1] + y) && img.width > (spos[0] + x))
                            {
                                //get pixel from pos
                                let pix = context2d.getImageData(spos[0] + x, img.height - (spos[1] + y + 1) , 1, 1).data;

                                if(pix[3] > 0 || document.getElementById("ctrans").checked) {
                                    hasColor = true;
                                }

                                //avoids the full white to be removed after processing
                                if (pix[0] == 255 && pix[1] == 255 && pix[2] == 255 && pix[3] == 255) {
                                    pix = [254,254,254,255]; 
                                }

                                // avoids image corruption
                                if(pix[3] == 1 && pix[1] == 0 && pix[0] < 33 && pix[2] < 9)
                                {pix[3] = 2;}

                                //apply pixel
                                if(sx + 1==signs[0] && sy + 1==signs[1] && pix[3] == 0 && document.getElementById("btrans").checked){
                                    
                                }
                                else{
                                    palletes += ";" + signColors[x + 1][y + 1] + "=" + rgbaToHex(pix[0],pix[1],pix[2],pix[3]);
                                }
                            }
                        }
                    }
                    if (hasColor && palletes != "?replace"){
                        directives += sign + palletes;
                    }
                }
            }
            
            //final processing
            directives += "?replace;ffff=0000";
            return srcDirectory + directives;
        }

    </script>
</html> 
