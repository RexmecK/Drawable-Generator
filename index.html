<!DOCTYPE html>
<html>

	<head>
		<title>Rexmeck's Drawable Generator</title>
		<style>
			/* width */
			textarea::-webkit-scrollbar {
			  width: 18px;
			}

			/* Track */
			textarea::-webkit-scrollbar-track {
			  background: #202020;
				border-radius: 2px;
			}

			/* Handle */
			textarea::-webkit-scrollbar-thumb {
				background: #303030;
				border-radius: 4px;
				border: 2px solid #202020;
			}

			/* Handle on hover */
			textarea::-webkit-scrollbar-thumb:hover {
			  background: #303030;
				border-radius: 4px;
				border: 2px solid #202020;
			}

			.default-font {
				
				font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";
				font-size: 13pt;
				font-weight:lighter;
				-webkit-font-smoothing: antialiased;
				color: #fafafa;
			}
			
			.default-button {
				color: #fafafa;
				background-color : #202020; 
				border: 4px solid #202020;
			}

			input, textarea, button {

				border-radius: 4px;
				background : #202020; 
				border: 0px;
				color: #fafafa;
			}
			input::-webkit-file-upload-button {
				visibility: hidden;
			}
			input::before {
				content: 'Choose File';
				display: inline-block;
				border-radius: 2px;
				border: 2px solid #808080;
				background-color: #202020;
				padding: 2px 4px;
				-webkit-user-select: none;
				cursor: pointer;
			}

			body {
				height: 100vh;
				margin: 0;
				background-color: #000;
				padding: 0;
				position: relative;
			}

			.header {
				overflow: hidden;
				background-color: #202020;
				top: 0;
				left: 0;
				right: 0;
				bottom: 100%;
				max-height: 60px;
				z-index: 99;
			}

			#generating {
				display: none;
			}
			.middle-align {
				overflow: hidden;
				max-width: 960px;
				margin-left: auto;
				margin-right: auto;
			}
			
			.shadow {
				box-shadow: 0px 0px 10px 0px #00000040;
			}

			.page-element {
				margin-top: 30px;
				border-radius: 4px;
			}

			.page-content {
				padding-top: 30px; 
				padding-left: 3.5%; 
				padding-right: 5%;
				padding-bottom: 30px;
			}

			#drop {
					position: fixed;
					top: 0; 
					left: 0; 
					z-index: 999;
					width: 100%; 
					height: 100%;
					background-color: 
					rgba(0,0,0,0.75);
					transition: visibility 200ms, opacity 200ms;
			}

			.checkbox input[type="checkbox"] {
					position: relative;
					z-index: 999;
					opacity: 0;
					transform: scale(1.5);
			}

			.checkbox label {
					position: relative;
					display: inline-block;
					padding-left: 2px;
			}

			.checkbox label::before, .checkbox label::after {
					position: absolute;
					content: "";
					display: inline-block;
			}

			.checkbox label::before{
					height: 16px;
					width: 16px;

					border-radius: 4px;
					background-color: #202020;
					left: -22px;
					top: 3px;
			}

			.checkbox label::after {
					height: 0px;
					width: 0px;
					border-radius: 2px;
					border-left: 8px solid #fafafa;
					border-bottom: 8px solid #fafafa;
			
					left: -18px;
					top: 7px;
			}

			.checkbox input[type="checkbox"] + label::after {
					content: none;
			}

			.checkbox input[type="checkbox"]:checked + label::after {
					content: "";
			}


		</style>
	</head>
	
	<body>
		
		<div style="visibility:hidden; opacity:0" id="drop">
			<h1 align="center" class="default-font" style="top: 0; left: 0; font-size: 50px; margin-top: 12.5%; color:#fafafa;">Drop to generate</h1>
		</div>
		<!--Main page-->
		<div class="middle-align shadow page-element" style="background-color: #303030; min-width: 120px;" id="body">
			<div class="header shadow">
				<h1 align="center" class="default-font" style="font-size: 1cm; color:#808080; margin-top: 0.5%;">Rexmeck's Drawable Generator</h1>
			</div>
			<div class="page-content">
				<label class="default-font">Input: </label>
				<br>
				<br>
				<button name="generate" onclick="generate()" class="default-button">Generate</button>
				<input type="file" id="input" accept="image/*" class="default-button">
				<label id="generating" class="default-font" ></label>
				<br>
				<br>
				<label class="default-font">Output: </label>
				<br>
				<br>
				<textarea id="output" wrap="soft" spellcheck="false" style="max-width:100%; min-width: 100%; height: 250px; resize: vertical;"> </textarea>
			</div>
		</div>
		
		<div class="middle-align shadow page-element" style=" background-color: #303030; min-width: 120px;">
			<div class="header shadow">
				<h1 align="center" class="default-font" style="font-size: 1cm; color:#808080; margin-top: 0.5%;">Advanced Settings</h1>
			</div>
			<div class="page-content">
				<label class="default-font">Source Image Path:</label>
				<br>


				<input type="text" id="imagePathTextBox" value="/assetmissing.png" class="default-font" style="max-width:100%; min-width: 100%;" title="Change our base sprite to make drawables on. Its recommended to use the default">
				<br>
				<br>
				<label class="default-font">Green Index</label>
				<input type="text" id="greenIndexTextBox" value="00" maxlength="2" class="default-font" style="max-width:36px; min-width: 0%;" title="Useful for animated drawables">
				<br>
				<br>
				<div class="checkbox">
					<input type="checkbox" id="compressColorCheckBox" title="Round color values to smaller hex color"></input>
					<label class="default-font">Color Compression</label>
				</div>
				<br>
				<div class="checkbox">
					<input type="checkbox" id="pixelMapOnlyCheckBox" title="Useful for animated drawables (experimental!)"></input>
					<label class="default-font">Pixel map data only</label>
				</div>
				<br>
				<h1 align="left" class="default-font" style="font-size: 1cm; color:#202020; margin-top: 0.5%;">Legacy Settings</h1>
				<div class="checkbox">
					<input type="checkbox" id="checkboxlegacy" class="default-font" title="Use old method if the new method doesn't work properly"></input>
					<label class="default-font">Generate legacy drawables</label>
				</div>
				<br>
				<div class="checkbox">
					<input type="checkbox" id="bypassTransparentLastSign" title="The last sign will not have transparent coords removal (slightly saves some data)"></input>
					<label class="default-font" >Bypass transparent on last signplaceholder</label>
				</div>
				<br>
				<div class="checkbox">
					<input type="checkbox" id="RetainColorValue" title="Takes full transparent with color codes instead of turning it into 0000."></input>
					<label class="default-font">Retain color value even if transparent</label>
				</div>
				<br>
				<br>
			</div>
		</div>

	</body>
	
	<script>

		//Util credits from people on stackoverflow
		function componentToHex(c)
		{
			var hex = c.toString(16);
			return hex.length == 1 ? "0" + hex : hex;
		}
		
		function shortableHex(v)
		{
			for(var i=0;i<16;i++)
			{
				if(v == i * 17)
				{
					return true;
				}
			}
			return false;
		}

		function shortableRGBA(rgba) //rgba can be rgb array
		{
			for(i = 0; i < rgba.length; i++)
			{
				if(!shortableHex(rgba[i]))
				{
					return false
				}	
			}
			return true
		}

		function rgbaToHex(r, g, b, a, NoTransparentCheck)
		{
			let rgba = [r,g,b,a]
			if((a == null) || (a == 255))
				rgba.pop()
			

			if(rgba[3] && rgba[3] == 0 && !document.getElementById("RetainColorValue").checked && !NoTransparentCheck)
				return "0000";
			

			let hex = ""

			if(shortableRGBA(rgba))
			{
				for(i = 0; i < rgba.length; i++)
				{
					hex += componentToHex(rgba[i]).substring(0, 1);
				}
			}
			else
			{
				for(i = 0; i < rgba.length; i++)
				{
					hex += componentToHex(rgba[i]);
				}
			}

			return hex
		}

		function compressColor(c)
		{
			return [
				Math.round(c[0] / 17) * 17,
				Math.round(c[1] / 17) * 17,
				Math.round(c[2] / 17) * 17,
				Math.round(c[3] / 17) * 17,
			]
		}

		var outputText = document.getElementById("output");
		var generatingtext = document.getElementById("generating");

		function generate(){
			let files = document.getElementById("input").files
			if (ready && files.length == 1) {
				readfile(files[0])
			}
			else
			{
				generatingtext.style.display = "none";
			}
		}

		function readfile(file)
		{
			outputText.value = "";
			generatingtext.style.display = "initial";
			generatingtext.innerHTML = "Generating...";

			let reader = new FileReader();
			reader.onload = function(a)
			{
				let img = new Image;
				img.onload = function(){

					if(img.height <= 256 && img.width <= 256 && !document.getElementById("checkboxlegacy").checked){
						generatingtext.innerHTML = "Generated!";
						outputText.value = drawFade(
							img,
							{
								pixelMapOnly: document.getElementById("pixelMapOnlyCheckBox").checked,
								imagePath: document.getElementById("imagePathTextBox").value,
								compressColor: document.getElementById("compressColorCheckBox").checked,
								greenIndex: document.getElementById("greenIndexTextBox").value
							}
						);
					}
					else
					{
						generatingtext.innerHTML = "Generated (legacy)!";
						outputText.value = drawLegacy(img,
							{
								pixelMapOnly: document.getElementById("pixelMapOnlyCheckBox").checked,
								imagePath: document.getElementById("imagePathTextBox").value,
								compressColor: document.getElementById("compressColorCheckBox").checked,
								greenIndex: document.getElementById("greenIndexTextBox").value
							}
						);
					}
				};
				img.onerror = function(a) {
						generatingtext.innerHTML = "Unable to generate";
				}
				img.src = a.target.result;
			}

			reader.readAsDataURL(file);
		}

		var lastTarget = null;

		//drag and drop stuff
		var drop = document.getElementById("drop");

		window.addEventListener("dragenter", function(e)
			{
				lastTarget = e.target;
				drop.style.visibility = "";
				drop.style.opacity = 1;
			}
		);

		window.addEventListener("dragover", function(e)
			{
				e.dataTransfer.dropEffect = 'copy';
				e.preventDefault();
			}
		);

		window.addEventListener("dragleave", function(e)
			{
				if(e.target === lastTarget || e.target === document)
				{
				 	drop.style.visibility = "hidden";
				 	drop.style.opacity = 0;
				}
			}
		);

		drop.addEventListener("drop", function(e)
			{
				if (e.preventDefault)
					e.preventDefault();
				
				if(e.dataTransfer.files.length == 1)
					readfile(e.dataTransfer.files[0]);
				
				drop.style.visibility = "hidden";
				drop.style.opacity = 0;
			}
		);

		//palettes color counter
		function palettesCount(image)
		{
			let img = document.createElement('canvas');
			img.width = image.width;
			img.height = image.height;
			let context2d = img.getContext('2d');
			context2d.drawImage(image, 0,0);
			let palettes = {}
			for (x = 0; x < img.width; x++)
			{
				for (y = 0; y < img.height; y++)
				{
					let colorData = context2d.getImageData(x, y, 1, 1).data;
					let hex = rgbaToHex(colorData[0], colorData[1], colorData[2], colorData[3]);
					palettes[hex] = (palettes[hex] != null ? palettes[hex] : 0) + 1;
				}
			}
			return palettes;
		}

		function palettesSubstitutes(palettes, greenIndex)
		{
			let replaces = {};
			let Index = [0, 0, 0, 15];
			let greenIndex2 = greenIndex ? greenIndex : 0;
			let greenIndexMin = Math.ceil(greenIndex2 / 17) + 1;
			let stop = false;

			if(greenIndex2 < 119)
			{
				Index[1] = greenIndexMin;
			}

			function incrementIndex()
			{
				Index[0] += 1;
				if(Index[0] > 15)
				{
					Index[0] = 0;
					Index[1] += 1;
				}
				if(Index[1] > 15)
				{
					Index[1] = greenIndexMin;
					Index[2] += 1;
				}
				if(Index[2] > 15)
				{
					Index[2] = 0;
					Index[3] -= 1;
				}
				if(Index[3] < 0)
				{
					stop = true
				}
			}

			for(var color in palettes)
			{
				if(color.length > 4 && palettes[color] > 3)
				{
					replaces[color] = rgbaToHex(Index[0]*17,Index[1]*17,Index[2]*17,Index[3]*17, true);
					incrementIndex();
					if(stop){break}

					//skip existing palettes
					while(palettes[rgbaToHex(Index[0]*17,Index[1]*17,Index[2]*17,Index[3]*17, true)])
					{
						incrementIndex();
						if(stop){break}
					}
				}
			}

			return replaces;
		}

		function palettesSubstitutesToOriginal(replaces)
		{
			let directives = "?replace"
			for(var color in replaces)
			{
				directives += ";" + replaces[color] + "=" + color;
			}
			if(directives == "?replace")
			{
				return "";
			}
			return directives;
		}

		//drawable
		function drawFade(image, options)
		{
			options = options ? options : {};

			let img = document.createElement('canvas');
			img.width = options.width ? options.width : image.width;
			img.height = options.height ? options.height : image.height;
			
			context2d = img.getContext('2d');
			context2d.drawImage(image, -(options.offset ? options.offset[0] : 0), -(options.offset ? options.offset[1] : 0));

			let srcImageDirectory = options.imagePath ? options.imagePath : "/assetmissing.png";

			//green index validation
			let greenIndex = Math.min(Math.max(parseInt(options.greenIndex, 16), 0), 255);
			if(isNaN(greenIndex))
			{
				greenIndex = 0;
			}

			let baseDirectives = "?crop;0;0;1;1?setcolor=fff?replace;fff0=fff?border=1;fff;000?scale=1.15;1.12?crop;1;1;3;3"
			
			//setup recipes for scaling
			baseDirectives +=
				"?replace" +
				";fbfbfb=" + rgbaToHex(0, greenIndex, 0,0,true) +
				";eaeaea=" + rgbaToHex(img.width, greenIndex, 0,0,true) +
				";e4e4e4=" + rgbaToHex(0, greenIndex, img.height, 0,true) +
				";6a6a6a=" + rgbaToHex(img.width, greenIndex, img.height, 0,true);

			//scale to make the drawable map
			baseDirectives += "?scale=" + (img.width - 0.5);
			if(img.width != img.height)
			{
				baseDirectives += ";" + (img.height - 0.5);
			}

			//crop left overs from scale borders
			let crop = [
				0,0,
				img.width, img.height
			]

			//it fixes 256x256 drawable
			if(img.width > 255)
			{
				crop[0] += 1;
				crop[2] += 1;
			}
			if(img.height > 255)
			{
				crop[1] += 1;
				crop[3] += 1;
			}
			
			baseDirectives += "?crop=" + crop.join(";");


			//palettes substitute replace longer with a shorter one temporarily
			let toReplace = {};
			if(!options.compressColor)
			{
				toReplace = palettesSubstitutes(palettesCount(image), greenIndex);
			}

			//pixeldata
			let pixelData = "?replace"
			for(let x = 0; x < img.width; x++)
			{
				for(let y = 0; y < img.height; y++)
				{
					let color = context2d.getImageData(x, img.height - y - 1, 1, 1).data;
					if (color[3] > 0)
					{
						if (options.compressColor)
						{
							color = compressColor(color)
						}
						let colorHex = rgbaToHex(color[0], color[1], color[2], color[3]);

						pixelData +=  ";" 
						+ rgbaToHex(x, greenIndex, y, 0, true) 
						+ "=" 
						+ (toReplace[colorHex] != null ? toReplace[colorHex] : colorHex); //use palettes substitutes or original color
					}
				}
			}

			//output

			if(options.pixelMapOnly)
			{
				srcImageDirectory = "";
				baseDirectives = "";
			}
			if(pixelData == "?replace")
			{
				return srcImageDirectory;
			}

			return srcImageDirectory + baseDirectives + pixelData + palettesSubstitutesToOriginal(toReplace);
		}

		function drawLegacy(image, options)
		{
			let img = document.createElement('canvas');
			img.width = image.width;
			img.height = image.height;

			context2d = img.getContext('2d');
			context2d.drawImage(image, 0, 0, image.width, image.height);
			
			options = options ? options : {};
			let srcImageDirectory = options.imagePath ? options.imagePath : "/assetmissing.png";
			
			let signSize = [32, 8];
			let signDirectory = "/objects/outpost/customsign/signplaceholder.png";
			let signColors = [["00000000"]];

			let bypassTransparentLastSign = document.getElementById("bypassTransparentLastSign").checked;
			let RetainColorValue = document.getElementById("RetainColorValue").checked;
			let compressColors = document.getElementById("compressColorCheckBox").checked;

			for(let x=1;x<=signSize[0];x++)
			{
				signColors[x] = [];
				for(let y=1;y<=signSize[1];y++)
				{
					let xx = (x+"");
					let yy = (x+"");

					if(x<10)
						xx = "0"+x;
					if(y<10)
						yy = "0"+y;

					signColors[x-1][y-1] = xx + "00" + yy + "00"
				}
			}
			//directives init
			let directives = "?crop=;0;0;1;1?setcolor=fff?replace;fff=ffffff02;fff0=ffffff02?scalenearest=" + image.width + ";" + image.height;
			
			//calculates how much signs to be place x y
			let signs = [
				Math.ceil(image.width / signSize[0]),
				Math.ceil(image.height / signSize[1]),
			]

			//palettes tags
			let toReplace = {};
			if(!options.compressColor)
			{
				toReplace = palettesSubstitutes(palettesCount(image), 0);
			}

			//iterate sign blocks
			for(let sy = 0; sy < signs[1];sy++)
			{
				for(let sx = 0; sx < signs[0];sx++)
				{
					//gets sign relative position to the image
					let spos = [sx * signSize[0], sy * signSize[1]];

					//new sign
					let sign = "?blendmult=" + signDirectory + ";" + (-sx * signSize[0]) + ";" + -(sy * signSize[1]);
					let palettes = "?replace";
					hasColor = false;
					
					//iterate pixels + sign blocks
					for(let x=0; x<signSize[0];x++)
					{
						for(let y=0; y<signSize[1];y++)
						{
							if (image.height > (spos[1] + y) && image.width > (spos[0] + x))
							{
								//get pixel from pos
								let colorData = context2d.getImageData(spos[0] + x, image.height - (spos[1] + y + 1) , 1, 1).data;

								if(colorData[3] > 0 || RetainColorValue)
								{
									hasColor = true;
								}

								//apply pixel
								if(sx + 1==signs[0] && sy + 1==signs[1] && colorData[3] == 0 && bypassTransparentLastSign){
									if (compressColors)
									{
										colorData = compressColor(colorData)
									}
									let colorHex = rgbaToHex(colorData[0],colorData[1],colorData[2],colorData[3]);
									palettes += ";" + signColors[x][y] + "=" + (toReplace[colorHex] != null ? toReplace[colorHex] : colorHex);
								}
								else
								{
									if (compressColors)
									{
										colorData = compressColor(colorData)
									}
									let colorHex = rgbaToHex(colorData[0],colorData[1],colorData[2],colorData[3]);
									palettes += ";" + signColors[x][y] + "=" + (toReplace[colorHex] != null ? toReplace[colorHex] : colorHex);
								}
							}
						}
					}
					if (hasColor && palettes != "?replace")
					{
						directives += sign + palettes;
					}
				}
			}
			
			//final processing
			return srcImageDirectory + directives + palettesSubstitutesToOriginal(toReplace);
		}

		//web visuals

		function lerp(a,b,r)
		{
			return a+(b-a)*r;
		}

		var speed = 1/16;

		var lastColor = [0, 212, 219];
		var targetColor = [70, 112, 16];
			
		var current_lastColor = [0, 0, 0];
		var current_targetColor = [0, 0, 0];

		function tick()
		{
			current_lastColor = [lerp(current_lastColor[0], lastColor[0], speed), lerp(current_lastColor[1], lastColor[1], speed), lerp(current_lastColor[2], lastColor[2], speed)];
			current_targetColor = [lerp(current_targetColor[0], targetColor[0], speed), lerp(current_targetColor[1], targetColor[1], speed), lerp(current_targetColor[2], targetColor[2], speed)];
			document.body.style.backgroundImage = "linear-gradient(90deg, rgb("+current_targetColor[0]+","+current_targetColor[1]+","+current_targetColor[2]+"),rgb("+current_lastColor[0]+","+current_lastColor[1]+","+current_lastColor[2]+"))";
		}

		function tick2()
		{
			lastColor = targetColor;
			targetColor = [Math.random() * 255, Math.random() * 255, Math.random() * 255];
		}

		tick();
		tick2();

		setInterval(tick2,4000);
		setInterval(tick,64);
	</script>
</html>