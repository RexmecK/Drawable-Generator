<!DOCTYPE html>
<html>

    <head>
        <title>Rexmeck Drawable Generator</title>
        <style>
            .default-font {
                font-family: Arial, Helvetica, sans-serif;
                font-size: 0.5cm;
            }
            
            .default-button {
                color: #111; 
                border: 2px solid #888; 
                border-radius: 4px; 
                background-color: #eee;
            }

            body {
              height: 100vh;
              margin: 0;
              padding: 0;
              position: relative;
            }

            .header {
                overflow: hidden;
                background-color: #202020;
                top: 0;
                left: 0;
                right: 0;
                bottom: 100%;
                max-height: 8cm;
                z-index: 99;
            }

            #generating {
                display: none;
            }
            .middle-align {
                overflow: hidden;
                max-width: 960px;
                margin-left: auto;
                margin-right: auto;
            }

        </style>
    </head>
    
    <body>
        <div class="header">
            <h1 align="center" style="font-size: 1cm; color:#808080; font-family:'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif; font-weight: normal; margin-top: 15px;">Rexmeck Drawable Generator</h1>
        </div>
        <!--Main page-->
        <div style="padding-top:30px"></div>
        <div class="middle-align" style="padding-top: 30px; box-shadow: 0px 10px 40px 10px #00000040; background-color: #fafafa; min-width: 120px;">
            <div style="padding-left: 3.5%; padding-right: 5%;">
                <label class="default-font">Input: </label>
                <br>
                <button name="generate" onclick="generate()" class="default-button">Generate</button>
                <input type="file" id="input" accept="image/*" class="default-button">
                <label id="generating" class="default-font" >Generating...</label>
                <br>
                <label class="default-font">Source Image Path:</label>
                <br>
                <input type="text" id="srcPath" value="/assetmissing.png" class="default-font" title="Change our base sprite to make drawables on. Its recommended to use the default">
                <br>
                <label class="default-font">Source Image Size:</label>
                <br>
                <input class="default-font" type="number" id="srcX" value="64" min="1">
                <input class="default-font" type="number" id="srcY" value="64" min="1">
                <br>
                <input type="checkbox" id="btrans" class="default-font" title="The last sign will not have extra processing to remove his color coords (saving some data)"></input>
                <label class="default-font">Bypass transparent on last signplaceholder</label>
                <br>
                <input type="checkbox" id="ctrans" class="default-font" title="Takes full transparent with color codes instead of turning it into 0000."></input>
                <label class="default-font">Retain color value even if transparent</label>
                <br>
                <label class="default-font">Output: </label>
                <textarea id="output" wrap="soft" style="max-width:100%; min-width: 100%; resize: vertical;"> </textarea>
                <div style="padding-top: 30px;"></div>
            </div>
        </div>
    </body>
    
    <script>
        var ready = true

        //Util credits from people on stackoverflow
        function componentToHex(c) {
            var hex = c.toString(16);
            return hex.length == 1 ? "0" + hex : hex;
        }
        
        function hexEnd0(v) {
            for(var i=0;i<16;i++){
                if(v == i * 17) {
                    return true;
                }
            }
            return false;
        }

        function rgbaToHex(r, g, b, a) {
            //very bad coding here

            if(a == 0 && !document.getElementById("ctrans").checked) {
                return "0000";
            }

            if(hexEnd0(r) && hexEnd0(g) && hexEnd0(b)) {
                if (a == 255) {
                    return componentToHex(r).substring(0, 1) + componentToHex(g).substring(0, 1) + componentToHex(b).substring(0, 1);
                }
                else{
                    if(hexEnd0(a)){
                        return componentToHex(r).substring(0, 1) + componentToHex(g).substring(0, 1) + componentToHex(b).substring(0, 1) + componentToHex(a).substring(0, 1);
                    }
                }
            }

            return componentToHex(r) + componentToHex(g) + componentToHex(b) + componentToHex(a);
        }
        //

        //button callback
        function generate(){
            let outputText = document.getElementById("output");
            let generatingtext = document.getElementById("generating");
            outputText.value = "";

            generatingtext.style.display = "initial";
            
            if (ready && document.getElementById("input").files.length == 1 && document.getElementById("srcX").value > 0 && document.getElementById("srcY").value > 0) {
                ready = false
                let reader = new FileReader();
                let f = document.getElementById("input").files[0];
                reader.onload = function(a) 
                {
                    let img = new Image;
                    img.onload = function() { 
                        document.getElementById("output").value = draw(img); 
                        generatingtext.style.display = "none";
                        ready = true
                    } ;
                    img.src = a.target.result;
                }
                reader.readAsDataURL(f);
            }
            else
            {
                generatingtext.style.display = "none";
            }
            
            
        }
        
        function draw(image) {
            //we would create a canves to get pixel colors
            let img = document.createElement('canvas');
            img.width = image.width;
            img.height = image.height;
            context2d = img.getContext('2d');
            context2d.drawImage(image, 0, 0, image.width, image.height);
            
            let srcDirectory = document.getElementById("srcPath").value;
            let srcSize = [document.getElementById("srcX").value, document.getElementById("srcY").value];
            
            let signSize = [32, 8];
            let signDirectory = "/objects/outpost/customsign/signplaceholder.png";
            let signColors = [["00000001"]];

            for(let x=1;x<=signSize[0];x++){
                signColors[x] = [];
                for(let y=1;y<=signSize[1];y++){
                    signColors[x][y] = "";
                    if(x < 10){ signColors[x][y] += "0" + x; } else { signColors[x][y] += x;}
                    signColors[x][y] += "00";
                    if(y < 10){ signColors[x][y] += "0" + y; } else { signColors[x][y] += y;}
                    signColors[x][y] += "01";
                }
            }
            //directives init
            let directives = "?setcolor=ffff?replace;0000=ffff;fff0=ffff?scalenearest=" + (image.width / srcSize[0]) + ";" + (image.height / srcSize[1]);
            
            //calculates how much signs to be place x y
            signs = [
                Math.ceil(image.width / signSize[0]),
                Math.ceil(image.height / signSize[1]),
            ]

            //iterate sign blocks
                for(let sy = 0; sy < signs[1];sy++){
            for(let sx = 0; sx < signs[0];sx++){

                    //gets sign relative position to the image
                    let spos = [sx * signSize[0], sy * signSize[1]];

                    //new sign
                    let sign = "?blendmult=" + signDirectory + ";" + (-sx * signSize[0]) + ";" + -(sy * signSize[1]);
                    let palletes = "?replace";
                    hasColor = false;
                    
                    //iterate pixels + sign blocks
                    for(let x=0; x<signSize[0];x++) 
                    {
                        for(let y=0; y<signSize[1];y++)
                        {
                            if (img.height > (spos[1] + y) && img.width > (spos[0] + x))
                            {
                                //get pixel from pos
                                let pix = context2d.getImageData(spos[0] + x, img.height - (spos[1] + y + 1) , 1, 1).data;

                                if(pix[3] > 0 || document.getElementById("ctrans").checked) {
                                    hasColor = true;
                                }

                                // avoids image corruption
                                if(pix[3] == 1 && pix[1] == 0 && pix[0] < 33 && pix[2] < 9)
                                {
                                    pix[3] = 2;
                                }

                                //avoids the full white to be removed after processing and it will be restored
                                if (pix[0] == 255 && pix[1] == 255 && pix[2] == 255 && pix[3] == 255) {
                                    pix = [01,02,01,01]; 
                                }

                                //apply pixel
                                if(sx + 1==signs[0] && sy + 1==signs[1] && pix[3] == 0 && document.getElementById("btrans").checked){
                                    
                                }
                                else{
                                    palletes += ";" + signColors[x + 1][y + 1] + "=" + rgbaToHex(pix[0],pix[1],pix[2],pix[3]);
                                }
                            }
                        }
                    }
                    if (hasColor && palletes != "?replace"){
                        directives += sign + palletes;
                    }
                }
            }
            
            //final processing
            directives += "?replace;ffff=0000;01020101=ffff";
            return srcDirectory + directives;
        }

    </script>
</html> 
