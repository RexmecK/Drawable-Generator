<!DOCTYPE html>
<html>

    <head>
        <title>Rexmeck Drawable Generator</title>
        <style>
            .default-font {
                font-family: Arial, Helvetica, sans-serif;
                font-size: 0.5cm;
            }
            
            .default-button {
                color: #111; 
                border: 2px solid #888; 
                border-radius: 4px; 
                background-color: #eee;
            }

            body {
              height: 100vh;
              margin: 0;
              padding: 0;
              position: relative;
            }

            .header {
                overflow: hidden;
                background-color: #202020;
                top: 0;
                left: 0;
                right: 0;
                bottom: 100%;
                max-height: 8cm;
                z-index: 99;
            }

            #generating {
                display: none;
            }
            .middle-align {
                overflow: hidden;
                max-width: 960px;
                margin-left: auto;
                margin-right: auto;
            }

        </style>
    </head>
    
    <body>
        <div class="header">
            <h1 align="center" style="font-size: 1cm; color:#808080; font-family:'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif; font-weight: normal; margin-top: 15px;">Rexmeck Drawable Generator</h1>
        </div>
        <!--Main page-->
        <div style="padding-top:30px"></div>
        <div class="middle-align" style="padding-top: 30px; box-shadow: 0px 10px 40px 10px #00000040; background-color: #fafafa; min-width: 120px;">
            <div style="padding-left: 3.5%; padding-right: 5%;">
                <label class="default-font">Input: </label>
                <br>
                <button name="generate" onclick="generate()" class="default-button">Generate</button>
                <input type="file" id="input" accept="image/*" class="default-button">
                <label id="generating" class="default-font" >Generating...</label>
                <br>
                <label class="default-font">Source Image Path:</label>
                <br>
                <input type="text" id="srcPath" value="/assetmissing.png" class="default-font" title="Change our base sprite to make drawables on. Its recommended to use the default">
                <br>
                <br>
                <input type="checkbox" id="checkboxlegacy" class="default-font" title="Use old method if the new method doesn't work properly"></input>
                <label class="default-font">Generate legacy drawables</label>
                <br>
                <label class="default-font">Source Image Size (legacy):</label>
                <br>
                <input class="default-font" type="number" id="srcX" value="64" min="1">
                <input class="default-font" type="number" id="srcY" value="64" min="1">
                <br>
                <input type="checkbox" id="btrans" class="default-font" title="The last sign will not have transparent coords removal (slightly saves some data)"></input>
                <label class="default-font" >Bypass transparent on last signplaceholder (legacy)</label>
                <input type="checkbox" id="ctrans" class="default-font" style="display: none;"title="Takes full transparent with color codes instead of turning it into 0000."></input>
                <label class="default-font" style="display: none;">Retain color value even if transparent</label>
                <br>
                <label class="default-font">Output: </label>
                <textarea id="output" wrap="soft" style="max-width:100%; min-width: 100%; height: 250px; resize: vertical;"> </textarea>
                <div style="padding-top: 30px;"></div>
            </div>
        </div>
    </body>
    
    <script>
        var ready = true

        //Util credits from people on stackoverflow
        function componentToHex(c) {
            var hex = c.toString(16);
            return hex.length == 1 ? "0" + hex : hex;
        }
        
        function hexEnd0(v) {
            for(var i=0;i<16;i++){
                if(v == i * 17) {
                    return true;
                }
            }
            return false;
        }

        function rgbaToHex(r, g, b, a) {
            //very bad coding here
            r = Math.min(r,255);
            g = Math.min(g,255);
            b = Math.min(b,255);
            a = Math.min(a,255);

            if(a == 0 && !document.getElementById("ctrans").checked) {
                return "0000";
            }

            if(hexEnd0(r) && hexEnd0(g) && hexEnd0(b)) {
                if (a == 255) {
                    return componentToHex(r).substring(0, 1) + componentToHex(g).substring(0, 1) + componentToHex(b).substring(0, 1);
                }
                else{
                    if(hexEnd0(a)){
                        return componentToHex(r).substring(0, 1) + componentToHex(g).substring(0, 1) + componentToHex(b).substring(0, 1) + componentToHex(a).substring(0, 1);
                    }
                }
            }
            if(a == 255){
                return componentToHex(r) + componentToHex(g) + componentToHex(b)
            }
            return componentToHex(r) + componentToHex(g) + componentToHex(b) + componentToHex(a);
        }

        function rgbaToHexNoTransparentCheck(r, g, b, a) {
            r = Math.min(r,255);
            g = Math.min(g,255);
            b = Math.min(b,255);
            a = Math.min(a,255);
            if(hexEnd0(r) && hexEnd0(g) && hexEnd0(b)) {
                if (a == 255) {
                    return componentToHex(r).substring(0, 1) + componentToHex(g).substring(0, 1) + componentToHex(b).substring(0, 1);
                }
                else{
                    if(hexEnd0(a)){
                        return componentToHex(r).substring(0, 1) + componentToHex(g).substring(0, 1) + componentToHex(b).substring(0, 1) + componentToHex(a).substring(0, 1);
                    }
                }
            }

            if(a == 255){
                return componentToHex(r) + componentToHex(g) + componentToHex(b)
            }
            return componentToHex(r) + componentToHex(g) + componentToHex(b) + componentToHex(a);
        }
        //

        //button callback
        function generate(){
            let outputText = document.getElementById("output");
            let generatingtext = document.getElementById("generating");
            outputText.value = "";

            generatingtext.style.display = "initial";
            
            if (ready && document.getElementById("input").files.length == 1 && document.getElementById("srcX").value > 0 && document.getElementById("srcY").value > 0) {
                ready = false
                let reader = new FileReader();
                let f = document.getElementById("input").files[0];
                reader.onload = function(a) 
                {
                    let img = new Image;
                    img.onload = function() { 
                        if(img.height <= 255 && img.width <= 255 && !document.getElementById("checkboxlegacy").checked){
                            document.getElementById("output").value = drawFade(img); 
                        }
                        else
                        {
                            document.getElementById("output").value = drawLegacy(img); 
                        }
                        generatingtext.style.display = "none";
                        ready = true
                    } ;
                    img.src = a.target.result;
                }
                reader.readAsDataURL(f);
            }
            else
            {
                generatingtext.style.display = "none";
            }
            
            
        }

        function stepsize(x)
        {
            return Math.ceil(Math.min(x, 256) / 128) * 128;
        }

        function drawFade(image) {
            let img = document.createElement('canvas');
            img.width = image.width + 2;
            img.height = image.height + 2;
            context2d = img.getContext('2d');
            context2d.drawImage(image, 0,0);

            let fixsize = [stepsize(image.width), stepsize(image.height)];
            let srcDirectory = document.getElementById("srcPath").value;
            let srcSize = [document.getElementById("srcX").value, document.getElementById("srcY").value];
            let directives = "?crop=;0;0;1;1?setcolor=fff?replace;0000=0a00;fff0=0a00;fff=0a00?scalenearest=2?blendscreen=/objects/outpost/customsign/signplaceholder.png"
            
            //setgradient
            directives += //"?replace;0a00=" + rgbaToHexNoTransparentCheck(0, 170, 0,0) +
                        "?replace;01aa0000=" + rgbaToHexNoTransparentCheck(fixsize[0], 170, 0,0) +
                        ";00aa0100=" + rgbaToHexNoTransparentCheck(0, 170, fixsize[1], 0) +
                        ";01aa0100=" + rgbaToHexNoTransparentCheck(fixsize[0], 170, fixsize[1], 0);

            //setoptimizedsize
            directives += "?scale=" + (fixsize[0]) + ";" + (fixsize[1]); 
            //size
            directives += "?crop=" + Math.round(fixsize[0]/512) + ";" + Math.round(fixsize[1]/512) + ";" + (image.width + Math.round(fixsize[0]/512)) + ";" + (image.height + Math.round(fixsize[1]/512));

            let palletes = ""

            for(let sx = 1; sx <= image.width + 1; sx++)
            {
                for(let sy = 1; sy <= image.height + 1; sy++)
                {
                    let ssx = sx - 1
                    let ssy = image.height - sy
                    let pix = context2d.getImageData(ssx, ssy, 1, 1).data;
                    if (pix[3] > 0){ 
                        palletes += ";" + rgbaToHexNoTransparentCheck(sx - Math.round(fixsize[0]/256),170,sy - Math.round(fixsize[1]/256),0) + "=" + rgbaToHex(pix[0], pix[1], pix[2], pix[3]);
                    }
                    else{
                    }
                }
            }

            if(palletes == ""){
                return srcDirectory;
            }

            return srcDirectory + directives + "?replace" + palletes;
        }

        function drawLegacy(image) {
            let img = document.createElement('canvas');
            img.width = image.width;
            img.height = image.height;
            context2d = img.getContext('2d');
            context2d.drawImage(image, 0, 0, image.width, image.height);
            
            let srcDirectory = document.getElementById("srcPath").value;
            let srcSize = [document.getElementById("srcX").value, document.getElementById("srcY").value];
            
            let signSize = [32, 8];
            let signDirectory = "/objects/outpost/customsign/signplaceholder.png";
            let signColors = [["00000001"]];

            for(let x=1;x<=signSize[0];x++){
                signColors[x] = [];
                for(let y=1;y<=signSize[1];y++){
                    signColors[x][y] = "";
                    if(x < 10){ signColors[x][y] += "0" + x; } else { signColors[x][y] += x;}
                    signColors[x][y] += "00";
                    if(y < 10){ signColors[x][y] += "0" + y; } else { signColors[x][y] += y;}
                    signColors[x][y] += "01";
                }
            }
            //directives init
            let directives = "?setcolor=ffff?replace;0000=ffff;fff0=ffff?scalenearest=" + (image.width / srcSize[0]) + ";" + (image.height / srcSize[1]);
            
            //calculates how much signs to be place x y
            signs = [
                Math.ceil(image.width / signSize[0]),
                Math.ceil(image.height / signSize[1]),
            ]

            //iterate sign blocks
            for(let sy = 0; sy < signs[1];sy++){
                for(let sx = 0; sx < signs[0];sx++){

                    //gets sign relative position to the image
                    let spos = [sx * signSize[0], sy * signSize[1]];

                    //new sign
                    let sign = "?blendmult=" + signDirectory + ";" + (-sx * signSize[0]) + ";" + -(sy * signSize[1]);
                    let palletes = "?replace";
                    hasColor = false;
                    
                    //iterate pixels + sign blocks
                    for(let x=0; x<signSize[0];x++) 
                    {
                        for(let y=0; y<signSize[1];y++)
                        {
                            if (image.height > (spos[1] + y) && image.width > (spos[0] + x))
                            {
                                //get pixel from pos
                                let pix = context2d.getImageData(spos[0] + x, image.height - (spos[1] + y + 1) , 1, 1).data;

                                if(pix[3] > 0 || document.getElementById("ctrans").checked) {
                                    hasColor = true;
                                }

                                // avoids image corruption
                                if(pix[3] == 1 && pix[1] == 0 && pix[0] < 33 && pix[2] < 9)
                                {
                                    pix[3] = 2;
                                }

                                //avoids the full white to be removed after processing and it will be restored
                                if (pix[0] == 255 && pix[1] == 255 && pix[2] == 255 && pix[3] == 255) {
                                    pix = [01,02,01,01]; 
                                }

                                //apply pixel
                                if(sx + 1==signs[0] && sy + 1==signs[1] && pix[3] == 0 && document.getElementById("btrans").checked){
                                    
                                }
                                else{
                                    palletes += ";" + signColors[x + 1][y + 1] + "=" + rgbaToHex(pix[0],pix[1],pix[2],pix[3]);
                                }
                            }
                        }
                    }
                    if (hasColor && palletes != "?replace"){
                        directives += sign + palletes;
                    }
                }
            }
            
            //final processing
            directives += "?replace;ffff=0000;01020101=ffff";
            return srcDirectory + directives;
        }

    </script>
</html> 
